import {mounted, render, mut, sig, mem, eff_on, each, if_then} from "./solid/monke.js";
import {hdom} from "./solid/hdom/index.js";
import {Q5} from "./q5/q5.js";
import CSS from "./css/css.js";
import * as ArenaType from "./arena.js";
import * as Tapri from "./solid/monke.js";
let canvas_dom;
let timeout = void 0;
const lerp = (start, stop, amt) => amt * (stop - start) + start;
const invlerp = (x, y, a) => clamp((a - x) / (y - x));
const clamp = (a, min = 0, max = 1) => Math.min(max, Math.max(min, a));
const range = (x1, y1, x2, y2, a) => lerp(x2, y2, invlerp(x1, y1, a));
const not = (value) => !value;
const between = (val, min, max) => val > min && val < max;
const mouse_x = sig(0);
const mouse_y = sig(0);
const rel_mouse_x = mem(() => mouse_x() / window.innerWidth);
const rel_mouse_y = mem(() => mouse_y() / window.innerHeight);
const colors = mut({
  base: "#E5FD53",
  highlight: "#9366C3",
  text: "#268E17",
  white: "#FFFFFF",
  black: "#4D4D4D"
});
const type = mut({
  heading: "anthony"
});
const {vw, px, vh, ms, css, url, em, rem, percent} = CSS;
const calc = (...args) => `calc(${args.join(" ")})`;
const fullscreen = {
  width: vw(100),
  height: vh(100)
};
const random_pos = (w = 10, h = 10) => ({
  x: (100 - w) * Math.random(),
  y: (100 - h) * Math.random()
});
const rect = (x, y, w, h, opts = {
  xAxis: "left",
  yAxis: "top",
  strategy: "fixed"
}) => ({
  [opts.xAxis]: x,
  [opts.yAxis]: y,
  width: w,
  height: h,
  position: opts.strategy
});
const loadfont = (src, name) => {
  return ["@font-face", {
    "font-family": name,
    src: url(src)
  }];
};
function Rectangle(x, y, w, h, opts) {
  const default_opts = {xAxis: "left", yAxis: "top", strategy: "fixed", unit: "px"};
  const _opts = sig(Object.assign(default_opts, opts));
  const _x = sig(x);
  const _y = sig(y);
  const _w = sig(w);
  const _h = sig(h);
  const _unit = (axis) => _opts().unit == "v" ? axis == "x" ? "vw" : "vh" : this.opts().unit;
  return {
    x: _x,
    y: _y,
    w: _w,
    h: _h,
    unit: _unit,
    xAxis: opts.xAxis,
    yAxis: opts.yAxis,
    strategy: opts.strategy,
    css: () => mem(() => css(rect(_x() + _unit("x"), _y() + _unit("y"), _w() + _unit("x"), _h() + _unit("y"), _opts())))
  };
}
function Environment() {
}
const Main = () => hdom([
  ["style", () => css(style)],
  [
    ".main",
    Resources.html,
    Ornament.html,
    Canvas.html,
    Schedule.html
  ]
]);
function init_p5(el) {
  let p = new Q5("instance", el);
  let r1 = 200;
  let r2 = 440;
  let text1 = "\u0905\u0932\u0917practiceseeee";
  let textc = "#9366C5";
  let e1font, e2font, e3font;
  p.setup = () => {
    p.createCanvas(window.innerWidth, window.innerWidth, {alpha: true});
    p.angleMode(p.DEGREES);
  };
  p.preload = () => {
    e1font = p.loadFont("./fonts/Rajdhani-Light.ttf");
    e2font = p.loadFont("./fonts/Rajdhani-Light.ttf");
    e3font = p.loadFont("./fonts/DuctusCalligraphic.otf");
  };
  let an = 0;
  function draw_character(angle, char) {
    p.textSize(70);
    p.noStroke();
    p.textAlign(p.CENTER, p.CENTER);
    let x = p.cos(angle) * r1;
    let y = p.sin(angle) * r2;
    p.rectMode(p.CENTER);
    let x1 = x * p.cos(an) - y * p.sin(an) + p.width / 2;
    let y1 = x * p.sin(an) + y * p.cos(an) + p.height / 4;
    if (angle > 80)
      p.textFont(e2font);
    else
      p.textFont(e1font);
    p.stroke(colors.white);
    p.noFill();
    p.circle(x1, y1, 80);
    p.fill(colors.white);
    p.noStroke();
    p.text(char, x1, y1);
  }
  p.draw = () => {
    p.clear();
    an = p.lerp(an, mouse_y() * mouse_x() / 300, 1e-3);
    p.stroke(255);
    p.noFill();
    text1.split("").forEach((char, i) => {
      let angle = 360 / text1.length * i;
      draw_character(angle, char);
    });
    r1 = 300 + p.cos(90 - an) * 80;
    r2 = 300 + p.sin(90 - an) * 120;
  };
}
const seek_rect = (pos, rectangle, inc = 8, t = 300, timeout2) => {
  if (timeout2)
    clearTimeout(timeout2);
  let diff_x = rectangle.x() - pos.x;
  let diff_y = rectangle.y() - pos.y;
  let new_x = rectangle.x() + (rectangle.x() < pos.x ? inc : inc * -1);
  let new_y = rectangle.y() + (rectangle.y() < pos.y ? inc : inc * -1);
  let need_update_x = Math.abs(diff_x) > inc;
  let need_update_y = Math.abs(diff_y) > inc;
  let update_fn_x = () => {
    rectangle.x(new_x);
    seek_rect(pos, rectangle, inc, t, timeout2);
  };
  let update_fn_y = () => {
    rectangle.y(new_y);
    seek_rect(pos, rectangle, inc, t, timeout2);
  };
  let fns = [];
  if (need_update_x)
    fns.push(update_fn_x);
  if (need_update_y)
    fns.push(update_fn_y);
  timeout2 = setTimeout(() => {
    const is = fns[Math.floor(Math.random() * fns.length)];
    if (is)
      is();
  }, t);
};
const Ornament = (() => {
  let rectangle = Rectangle(20, 30, 25, 40, {unit: "v"});
  let inlinecss = rectangle.css();
  let css2 = [".ornament", {
    background: colors.highlight,
    "background-size": [[px(40), px(40)]],
    "background-image": [
      "linear-gradient(to right, #2222 1px, transparent 1px)",
      "linear-gradient(to bottom, #2222 1px, transparent 1px)"
    ]
  }];
  let html = [".ornament", {style: inlinecss}];
  return {html, css: css2, rectangle};
})();
const Resources = (() => {
  let rectangle = Rectangle(40, 1, 100 - 40 - 1, 60, {unit: "v"});
  let style2 = rectangle.css();
  const html = [".resources", {style: style2}];
  const css2 = [".resources", {
    position: "fixed",
    background: colors.highlight,
    "background-size": [[px(40), px(40)]],
    "background-image": [
      "linear-gradient(to right, #2222 1px, transparent 1px)",
      "linear-gradient(to bottom, #2222 1px, transparent 1px)"
    ]
  }];
  return {css: css2, html, rectangle};
})();
let Schedule = function() {
  let css2 = [
    ".schedule",
    {
      "font-family": "monospace",
      background: colors.white,
      color: () => colors.text,
      transition: [["all", ms(200)]],
      cursor: "crosshair",
      display: "grid",
      "grid-template-rows": [[percent(20), percent(80)]]
    },
    ["h2", {padding: rem(1)}],
    [
      ".schedule-container",
      {
        height: percent(100),
        "overflow-y": "scroll"
      }
    ],
    [
      ".section",
      {
        padding: rem(0.25),
        "padding-bottom": rem(1.25),
        margin: [[0, rem(1.25)]],
        "border-top": [[px(1), "solid", colors.highlight]],
        color: colors.highlight
      },
      [":hover", {color: colors.white, "background-color": colors.highlight}],
      [".title", {"font-family": "ductus"}],
      [".time", {
        display: "block-inline",
        "background-color": colors.highlight,
        color: colors.white,
        padding: [[0, em(0.5)]],
        width: "min-content",
        "border-radius": px(15)
      }]
    ]
  ];
  let rectangle = Rectangle(1, 45, 30, 60, {unit: "v"});
  let inlincecss = rectangle.css();
  const html = [
    ".schedule",
    {
      onmouseenter: (e) => e.target == e.currentTarget ? rectangle.y(rectangle.y() + Math.random() * 5 - 2.5) : null,
      onmouseleave: (e) => e.target == e.currentTarget ? rectangle.y(Math.random() * 50) : null,
      style: inlincecss
    },
    ["h2", "Schedule"],
    [
      ".schedule-container",
      [
        ".section",
        [".title", "Eric Francisco"],
        [".time", "2pm"]
      ],
      [
        ".section",
        [".title", "Scott Deeming"],
        [".time", "3pm"]
      ],
      [
        ".section",
        [".title", "Garry Ing"],
        [".time", "3pm"]
      ],
      [
        ".section",
        [".title", "1RG"],
        [".time", "4pm"]
      ],
      [
        ".section",
        [".title", "E.L Guerero"],
        [".time", "4pm"]
      ],
      [
        ".section",
        [".title", "Symon Oliver"],
        [".time", "4pm"]
      ],
      [
        ".section",
        [".title", "SHEEP School"],
        [".time", "2pm"]
      ]
    ]
  ];
  return {html, css: css2, rectangle};
}();
let comps = [Schedule, Resources, Ornament];
setInterval(() => {
  comps.forEach((el) => {
    seek_rect(random_pos(el.rectangle.w(), el.rectangle.h()), el.rectangle, 5.5, 300);
  });
}, 5e3);
const Canvas = (() => {
  const html = () => hdom([".canvas", {ref: init_p5}]);
  const css2 = [".canvas", {position: "fixed"}, fullscreen];
  return {html, css: css2};
})();
let style = mut([
  loadfont("./fonts/Anthony.otf", "anthony"),
  loadfont("./fonts/TINY5x3GX.ttf", "tiny"),
  loadfont("./fonts/CirrusCumulus.otf", "cirrus"),
  loadfont("./fonts/Rajdhani-Light.ttf", "rajdhani"),
  loadfont("./fonts/DuctusCalligraphic.otf", "ductus"),
  ["*", {
    padding: 0,
    margin: 0,
    transition: [["all", ms(200)]]
  }],
  ...Array(5).fill(0).map((e, i) => ["h" + (i + 1), {"font-family": () => type.heading, "font-size": em(4 - i / 2)}]),
  [".main", {
    position: "fixed",
    background: colors.base,
    "background-size": [[px(100), px(100)]],
    "background-image": [
      "linear-gradient(to right, #2222 1px, transparent 1px)",
      "linear-gradient(to bottom, #2222 1px, transparent 1px)"
    ]
  }, fullscreen],
  Ornament.css,
  Canvas.css,
  Resources.css,
  Schedule.css
]);
document.body.onmousemove = (e) => {
  mouse_x(e.clientX);
  mouse_y(e.clientY);
};
let button = (click_fn, one, two) => {
  let atts = {onclick: click_fn};
  let text = two;
  if (typeof one == "object")
    Object.assign(atts, one);
  else if (typeof one == "string")
    text = one;
  return ["button", atts, text];
};
function label_number_input(label, getter, setter) {
  return [
    ".label-input",
    ["span.label", label],
    () => hdom(["input", {
      value: getter,
      type: "number",
      oninput: (e) => {
        let value = parseInt(e.target.value);
        if (isNaN(value))
          value = 0;
        setter(value);
      }
    }])
  ];
}
render(Main, document.body);
