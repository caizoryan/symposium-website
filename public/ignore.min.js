import {mounted, render, mut, sig, mem, eff_on, each, if_then} from "./chowk/monke.js";
import {hdom} from "./chowk/hdom/index.js";
import {Q5} from "./q5/q5.js";
import CSS from "./css/css.js";
import * as ArenaType from "./arena.js";
import * as Chowk from "./chowk/monke.js";
let canvas_dom;
let timeout = void 0;
const lerp = (start, stop, amt) => amt * (stop - start) + start;
const invlerp = (x, y, a) => clamp((a - x) / (y - x));
const clamp = (a, min = 0, max = 1) => Math.min(max, Math.max(min, a));
const range = (x1, y1, x2, y2, a) => lerp(x2, y2, invlerp(x1, y1, a));
const not = (value) => !value;
const toss = () => Math.random() > 0.5;
const between = (val, min, max) => val > min && val < max;
const mouse_x = sig(0);
const mouse_y = sig(0);
const rel_mouse_x = mem(() => mouse_x() / window.innerWidth);
const rel_mouse_y = mem(() => mouse_y() / window.innerHeight);
const colors = mut({
  base: "#E5FD53",
  highlight: "#9366C3",
  text: "#268E17",
  white: "#eeeeee",
  black: "#4D4D4D"
});
const type = mut({
  heading: "anthony"
});
const {vw, px, vh, ms, css, url, em, rem, percent} = CSS;
const calc = (...args) => `calc(${args.join(" ")})`;
const fullscreen = {
  width: vw(100),
  height: vh(100)
};
const random_pos = (w = 10, h = 10) => ({
  x: (100 - w) * Math.random(),
  y: (100 - h) * Math.random()
});
const offscreen = () => {
  let xr = Math.random() * 100;
  let yr = Math.random() * 100;
  let dx = toss() ? 1 : -1;
  let dy = toss() ? 1 : -1;
  let fx = dx > 0 ? 100 + xr : xr * dx;
  let fy = dy > 0 ? 100 + yr : yr * dy;
  return {x: fx, y: fy};
};
let call_everyone = () => {
  comps.forEach((el) => {
    let pos = random_pos(el.rectangle.w(), el.rectangle.h());
    el.rectangle.navigator.navigate_to(pos.x, pos.y, 30, 800);
  });
};
const rect = (x, y, w, h, opts = {
  xAxis: "left",
  yAxis: "top",
  strategy: "fixed"
}) => ({
  [opts.xAxis]: x,
  [opts.yAxis]: y,
  width: w,
  height: h,
  position: opts.strategy
});
const loadfont = (src, name) => {
  return ["@font-face", {
    "font-family": name,
    src: url(src)
  }];
};
let style = mut([
  loadfont("./fonts/Roberte-Regular.woff", "roberte"),
  loadfont("./fonts/Oracle.ttf", "oracle"),
  loadfont("./fonts/Anthony.otf", "anthony"),
  loadfont("./fonts/TINY5x3GX.ttf", "tiny"),
  loadfont("./fonts/CirrusCumulus.otf", "cirrus"),
  loadfont("./fonts/Rajdhani-Light.ttf", "rajdhani"),
  loadfont("./fonts/DuctusCalligraphic.otf", "ductus"),
  ["*", {
    padding: 0,
    margin: 0,
    transition: [["all", ms(20)]]
  }],
  ...Array(5).fill(0).map((e, i) => [
    "h" + (i + 1),
    {
      "font-family": () => type.heading,
      "font-size": em(4 - i / 2)
    }
  ]),
  [".main", {
    position: "fixed",
    background: colors.white,
    "background-size": [[px(100), px(100)]],
    "background-image": [
      "linear-gradient(to right, #2222 1px, transparent 1px)",
      "linear-gradient(to bottom, #2222 1px, transparent 1px)"
    ]
  }, fullscreen]
]);
function Navigator(rectangle) {
  let timeline = Timeline();
  let accumalator = (keys) => {
    let api = {
      queue: keys,
      padded: [],
      last_value: keys[0]?.start,
      addempty: (duration) => {
        let key = {start: api.last_value, end: api.last_value, duration};
        api.padded.push(key);
      },
      addnext: () => {
        let last = api.queue.shift();
        api.padded.push(last);
        api.last_value = last.end;
      }
    };
    return api;
  };
  let destination = sig({x: rectangle.x(), y: rectangle.y()});
  const navigate_to = (x, y, inc, int) => {
    timeline.clear();
    destination({x, y});
    const increment = () => inc ? inc : 15;
    const interval = () => int ? int : 500;
    let x_;
    let y_;
    if (x !== void 0) {
      x_ = accumalator(generate(rectangle.x(), x, increment(), interval()));
    }
    if (y !== void 0) {
      y_ = accumalator(generate(rectangle.y(), y, increment(), interval()));
    }
    while (x_.queue.length > 0 || y_.queue.length > 0) {
      let opts = [x_, y_];
      let random = Math.floor(Math.random() * opts.length);
      let item = opts.splice(random, 1)[0];
      if (item.queue.length == 0)
        continue;
      opts.forEach((e) => e.addempty(interval()));
      item.addnext();
    }
    timeline.add(animate.prop(x_.padded, rectangle.x).setEasing("InOutCubic"));
    timeline.add(animate.prop(y_.padded, rectangle.y).setEasing("InOutCubic"));
  };
  const generate = (from, to, increment, interval) => {
    let diff = to - from;
    let iterations = Math.ceil(Math.abs(diff) / increment);
    let last = from;
    let keyframes = Array(iterations).fill(0).map((e) => {
      let direction = last < to ? 1 : -1;
      let end = last + increment * direction;
      let crossed = direction > 0 ? end > to : end < to;
      end = crossed ? to : end;
      let key = {
        start: last,
        end,
        duration: interval
      };
      last = end;
      return key;
    });
    return keyframes;
  };
  return {navigate_to, destination, timeline};
}
class Rectangle {
  constructor(x, y, w, h, opts) {
    const default_opts = {xAxis: "left", yAxis: "top", strategy: "fixed", unit: "v"};
    this.opts = sig(Object.assign({}, default_opts, opts));
    this.x = sig(x);
    this.y = sig(y);
    this.w = sig(w);
    this.h = sig(h);
    this.children = [];
    this.navigator = Navigator(this);
    const derived = mem(() => ({
      x: this.x(),
      y: this.y(),
      w: this.w(),
      h: this.h()
    }));
    eff_on(this.navigator.destination, () => this.children.forEach((child) => {
      const obj = {
        ...derived(),
        ...this.navigator.destination()
      };
      child.follow(obj);
    }));
  }
  add_child(child) {
    this.children.push(child);
  }
  unit(prop) {
    const _opts = this.opts();
    const def = (axis) => _opts.unit === "v" ? axis === "x" ? "vw" : "vh" : _opts.unit;
    if (prop === "x")
      return _opts.xUnit ?? def("x");
    if (prop === "y")
      return _opts.yUnit ?? def("y");
    if (prop === "w")
      return _opts.wUnit ?? def("x");
    if (prop === "h")
      return _opts.hUnit ?? def("y");
  }
  css() {
    return mem(() => css(rect(this.x() + this.unit("x"), this.y() + this.unit("y"), this.w() + this.unit("w"), this.h() + this.unit("h"), this.opts())) + (this.opts().material?.css?.() ?? ""));
  }
}
function Child(element, followfn) {
  let html = element.html;
  let css2 = element.css;
  let rectangle = element.rectangle;
  let follow = followfn;
  return {html, css: css2, rectangle, follow};
}
function Squad(parent, children) {
}
function Clock() {
  const callbacks = [];
  const i = {};
  i.paused = false;
  i.pause = () => i.paused = false;
  i.play = () => i.paused = true;
  i.start = void 0;
  i.elapsed = sig(0);
  i.last = sig(0);
  i.add = (fn) => callbacks.push(fn);
  const run = (stamp) => {
    requestAnimationFrame(run);
    console.log("cb", callbacks.length);
    i.start ? null : i.start = stamp;
    i.elapsed(stamp - i.start);
    if (!i.paused) {
      callbacks.forEach((e, index, c) => e({
        stamp,
        start: i.start,
        delta: stamp - i.last(),
        elapsed: i.elapsed(),
        last: i.last(),
        destroy: () => c.splice(c.findIndex((f) => f === e), 1)
      }));
    }
    i.last(stamp);
  };
  requestAnimationFrame(run);
  return i;
}
let clock = Clock();
function Space(style_ref) {
  const space_entities = sig([]);
  const add_css = (css2) => style_ref.push(css2);
  const add = (el) => {
    if (el.css)
      add_css(el.css);
    space_entities([...space_entities(), el]);
  };
  const space_dom = mem(() => hdom([
    ".main",
    {onclick: call_everyone},
    ...space_entities().map((e) => e.html)
  ]));
  return {
    add,
    html: space_dom
  };
}
let space = Space(style);
function init_p5(el) {
  let p = new Q5("instance", el);
  let r1 = p.width / 4;
  let r2 = p.height / 4;
  let text1 = "\u0905\u0932\u0917practices";
  let textc = "#9366C5";
  let e1font, e2font, e3font;
  p.setup = () => {
    p.createCanvas(window.innerWidth, window.innerHeight, {alpha: true});
    p.angleMode(p.DEGREES);
  };
  p.preload = () => {
    e1font = p.loadFont("./fonts/Rajdhani-Light.ttf");
    e2font = p.loadFont("./fonts/Rajdhani-Light.ttf");
    e3font = p.loadFont("./fonts/DuctusCalligraphic.otf");
  };
  let an = 0;
  function draw_character(angle, char) {
    p.textSize(40);
    p.noStroke();
    p.textAlign(p.CENTER, p.CENTER);
    let x = p.cos(angle) * r1;
    let y = p.sin(angle) * r2;
    p.rectMode(p.CENTER);
    let x1 = x * p.cos(an) - y * p.sin(an) + p.width / 2;
    let y1 = x * p.sin(an) + y * p.cos(an) + p.height / 2;
    if (angle > 80)
      p.textFont(e2font);
    else
      p.textFont(e1font);
    p.stroke(colors.black);
    p.noFill();
    p.circle(x1, y1, 60);
    p.fill(colors.black);
    p.noStroke();
    p.text(char, x1, y1);
  }
  p.draw = () => {
    p.clear();
    an = p.lerp(an, mouse_y() * mouse_x() / 300, 1e-3);
    p.stroke(255);
    p.noFill();
    text1.split("").forEach((char, i) => {
      let angle = 360 / text1.length * i;
      draw_character(angle, char);
    });
    let rw = p.width / 4 - p.width / 12;
    let ry = p.height / 4 - p.height / 12;
    r1 = rw + p.cos(90 - an) * p.width / 10;
    r2 = ry + p.sin(90 - an) * p.height / 10;
  };
}
function Prop(clock2, keyframes, setter) {
  let should_destroy = false;
  const api = {
    active: true,
    looping: false,
    elapsedTime: 0,
    activeMotion: 0,
    currentValue: 0,
    keyframes: keyframes.map((key) => ({
      start: key.start,
      end: key.end,
      duration: key.duration,
      onend: key.onend,
      onstart: key.onstart,
      onupdate: key.onupdate,
      ondestroy: key.ondestroy,
      easing: key.easing ? key.easing : "linear"
    })),
    update(time) {
      let fps = 1e3 / time.delta;
      if (!_runChecks(time.destroy))
        return;
      let motion = api.keyframes[api.activeMotion];
      if (motion.onupdate)
        motion.onupdate();
      api.elapsedTime == 0 && motion.onstart ? motion.onstart() : null;
      api.elapsedTime += time.delta;
      api.currentValue = _calculate(motion);
      setter(api.currentValue);
    },
    add(keyframe) {
      const last = api.keyframes[api.keyframes.length - 1];
      api.keyframes.push({
        start: last.end,
        end: keyframe.end,
        duration: keyframe.duration,
        easing: keyframe.easing ? keyframe.easing : "linear"
      });
      return api;
    },
    destroy() {
      should_destroy = true;
    },
    animate() {
      api.active = true;
    },
    loop() {
      api.looping = true;
    },
    val() {
      return api.currentValue;
    },
    setEasing(easing) {
      api.keyframes.forEach((_, i, c) => c[i].easing = easing);
      return api;
    }
  };
  const _runChecks = (destroy) => {
    const motion = api.keyframes[api.activeMotion];
    if (api.elapsedTime >= motion.duration && motion.onend)
      motion.onend();
    if (should_destroy) {
      if (motion.ondestroy)
        motion.ondestroy("asked");
      destroy();
    }
    if (!api.active)
      return false;
    if (api.elapsedTime >= motion.duration) {
      if (api.activeMotion < api.keyframes.length - 1) {
        api.activeMotion++;
        api.elapsedTime = 0;
      } else {
        if (api.looping) {
          api.activeMotion = 0;
          api.elapsedTime = 0;
        } else {
          api.active = false;
          if (motion.ondestroy)
            motion.ondestroy("over and no loop");
          destroy();
          return false;
        }
      }
    }
    return true;
  };
  const _calculate = (motion) => {
    const progress = api.elapsedTime / motion.duration;
    return _interpolate(motion.start, motion.end, progress, motion.easing);
  };
  const _interpolate = (start, end, amt, easing) => {
    const easingFn = easing in Easings ? Easings[easing] : Easings.linear;
    return easingFn(amt) * (end - start) + start;
  };
  clock2.add(api.update);
  return api;
}
function Timeline() {
  const props = [];
  const api = {
    add(prop) {
      props.push(prop);
      return api;
    },
    loop() {
      props.forEach((p) => p.loop());
      return api;
    },
    animate() {
      props.forEach((p) => p.animate());
      return api;
    },
    pause() {
      props.forEach((p) => p.active = false);
      return api;
    },
    setEasing(easing) {
      props.forEach((p) => p.setEasing(easing));
      return api;
    },
    clear() {
      props.forEach((p) => p.destroy());
      props.length = 0;
    }
  };
  return api;
}
function Animator(clock2) {
  const prop = (keyframes, setter) => Prop(clock2, keyframes, setter);
  return {prop};
}
const animate = Animator(clock);
const seek_rect = (pos, rectangle, inc = 8, t = 300, timeout2) => {
  if (timeout2)
    clearTimeout(timeout2);
  let diff_x = rectangle.x() - pos.x;
  let diff_y = rectangle.y() - pos.y;
  let new_x = rectangle.x() + (rectangle.x() < pos.x ? inc : inc * -1);
  let new_y = rectangle.y() + (rectangle.y() < pos.y ? inc : inc * -1);
  let need_update_x = Math.abs(diff_x) > inc;
  let need_update_y = Math.abs(diff_y) > inc;
  let onend = () => seek_rect(pos, rectangle, inc, t, timeout2);
  let update_fn_x = () => {
    let start = rectangle.x();
    let end = new_x;
    animate.prop([{start, end, duration: t + 50, onend}], rectangle.x).setEasing("OutQuart");
  };
  let update_fn_y = () => {
    let start = rectangle.y();
    let end = new_y;
    animate.prop([{start, end, duration: t + 50, onend}], rectangle.y).setEasing("OutQuart");
  };
  let fns = [];
  if (need_update_x)
    fns.push(update_fn_x);
  if (need_update_y)
    fns.push(update_fn_y);
  timeout2 = setTimeout(() => {
    const is = fns[Math.floor(Math.random() * fns.length)];
    if (is)
      is();
  }, t);
};
const Main = () => hdom([["style", () => css(style)], space.html]);
const Banner = (() => {
  let {x, y} = offscreen();
  let rectangle = new Rectangle(x, y, 25, 40, {unit: "v"});
  let inlinecss = rectangle.css();
  let css2 = [".ornament", {
    background: colors.highlight,
    "background-size": [[px(40), px(40)]],
    "background-image": [
      "linear-gradient(to right, #2222 1px, transparent 1px)",
      "linear-gradient(to bottom, #2222 1px, transparent 1px)"
    ]
  }];
  let html = [".ornament", {style: inlinecss}];
  return {html, css: css2, rectangle};
})();
let colored_grid = (color, grid_size = 40) => ({
  css: () => CSS.css({
    background: color,
    "background-size": [[px(grid_size), px(grid_size)]],
    "background-image": [
      "linear-gradient(to right, #2222 1px, transparent 1px)",
      "linear-gradient(to bottom, #2222 1px, transparent 1px)"
    ]
  })
});
let purple_grid = colored_grid(colors.highlight, 40);
let white_grid = colored_grid(colors.white, 4);
const Information = (() => {
  let material = purple_grid;
  let {x, y} = offscreen();
  let rectangle = new Rectangle(x, y, 100 - 40 - 1, 60, {unit: "v", material});
  let style2 = rectangle.css();
  const html = [".resources", {style: style2}];
  const css2 = [".resources"];
  return {css: css2, html, rectangle};
})();
let Schedule = function() {
  let css2 = [
    ".schedule",
    {
      "font-family": "monospace",
      background: colors.white,
      color: () => colors.text,
      cursor: "crosshair",
      display: "grid",
      "grid-template-rows": [[percent(15), percent(85)]]
    },
    ["h2", {padding: rem(1)}],
    [".schedule-container", {
      height: percent(100),
      "overflow-y": "scroll"
    }],
    [
      ".section",
      {
        margin: [[0, rem(1.25)]],
        padding: rem(0.25),
        "padding-bottom": rem(1.25),
        "border-top": [[px(1), "solid", colors.highlight]],
        color: colors.highlight
      },
      [":hover", {
        color: colors.white,
        "background-color": colors.highlight
      }],
      [".title", {"font-family": "ductus"}],
      [".time", {
        display: "block-inline",
        padding: [[0, em(0.5)]],
        width: "min-content",
        "background-color": colors.highlight,
        color: colors.white,
        "border-radius": px(15)
      }]
    ]
  ];
  let {x, y} = offscreen();
  let rectangle = new Rectangle(x, y, 30, 60, {unit: "v"});
  let inlincecss = rectangle.css();
  const html = [
    ".schedule",
    {style: inlincecss},
    ["h2", ""],
    [
      ".schedule-container",
      [
        ".section",
        [".title", "Eric Francisco"],
        [".time", "2pm"]
      ],
      [
        ".section",
        [".title", "Scott Deeming"],
        [".time", "3pm"]
      ],
      [
        ".section",
        [".title", "Garry Ing"],
        [".time", "3pm"]
      ],
      [
        ".section",
        [".title", "1RG"],
        [".time", "4pm"]
      ],
      [
        ".section",
        [".title", "E.L Guerero"],
        [".time", "4pm"]
      ],
      [
        ".section",
        [".title", "Symon Oliver"],
        [".time", "4pm"]
      ],
      [
        ".section",
        [".title", "SHEEP School"],
        [".time", "2pm"]
      ]
    ]
  ];
  return {html, css: css2, rectangle};
}();
let Timing = function() {
  let css2 = [
    ".schedule",
    {
      "font-family": "monospace",
      background: colors.white,
      color: () => colors.text,
      cursor: "crosshair",
      border: ".5px dotted " + colors.highlight,
      "box-shadow": [[0, 0, px(30), px(10), colors.black + "11"]],
      padding: em(1),
      transition: "transform 400ms"
    },
    [".addy-container", {
      width: "min-content",
      "box-shadow": [[0, 0, px(30), px(10), colors.black + "11"]]
    }],
    ["h2.address", {
      "font-family": "oracle",
      "font-weight": 100,
      "line-height": em(1.5),
      "background-color": colors.white,
      color: colors.black,
      padding: [[0, px(5)]],
      "font-size": em(1.7),
      width: em(10)
    }],
    [".time", {
      transition: "transform 800ms",
      "background-color": colors.white,
      "font-size": em(2.3),
      "margin-top": px(10),
      "margin-bottom": px(40),
      width: em(10)
    }],
    ["h2.date", {
      "box-shadow": [[0, 0, px(30), px(10), colors.black + "11"]],
      transition: "transform 800ms",
      "font-family": "oracle",
      "font-weight": 100,
      "line-height": em(1.4),
      "background-color": colors.white,
      color: colors.black,
      "margin-bottom": em(0.5),
      padding: [[0, px(5)]],
      "font-size": em(2.7),
      "margin-left": em(3),
      width: em(5.5)
    }]
  ];
  let rectangle = new Rectangle(1, 45, 50, 23, {
    unit: "v",
    material: colored_grid(colors.white)
  });
  let ref = rectangle.css();
  let rotate = sig(3);
  let inlincecss = mem(() => ref() + `transform: rotate(${rotate()}deg)`);
  let resetrotate = (i) => setTimeout(() => {
    rotate(offset(8));
    resetrotate(Math.random() * 1500 + 1500);
  }, i);
  resetrotate(500);
  let address_rotate = mem(() => rotate() * -1 * 2);
  let date_rotate = mem(() => rotate() * -1);
  let addy_css = () => `transform: translateX(8px) rotate(${address_rotate()}deg)`;
  let date_css = () => `transform: translate(8px, 12px) rotate(${date_rotate()}deg) scale(1.2)`;
  const html = [
    ".schedule",
    {style: inlincecss},
    ["h2.date", {style: date_css}, "22 APRIL"],
    ["h4.time", {style: addy_css}, "4:00pm - 9:00pm"],
    [
      ".addy-container",
      ["h2.address", "113 McCaul"],
      ["h2.address", "(Annex Building)"],
      ["h2.address", "MCC 512"]
    ]
  ];
  return {html, css: css2, rectangle};
}();
const Stage = (() => {
  const html = () => hdom([".canvas", {ref: init_p5}]);
  const css2 = [".canvas", {position: "fixed", "mix-blend-mode": "difference"}, fullscreen];
  return {html, css: css2};
})();
document.body.onmousemove = (e) => {
  mouse_x(e.clientX);
  mouse_y(e.clientY);
};
let jump = (initial, then) => {
  let top = initial - 5;
  return [
    {start: initial, end: top, duration: 350, easing: "OutCubic"},
    {start: top, end: top - 0.5, duration: 150, easing: "OutCubic"},
    {start: top - 0.5, end: initial - 0.5, duration: 150, easing: "InCubic"},
    {start: initial - 0.5, end: initial, duration: 350, easing: "InCubic", onend: then}
  ];
};
let pause = (initial, then) => {
  return [
    {start: initial, end: initial + 1, duration: 800, easing: "OutCubic", onend: then}
  ];
};
let offset = (mul) => Math.random() * (toss() ? mul : mul * -1);
function follow_fn(rectangle, anchor) {
  return function(dims) {
    setTimeout(() => {
      let pos = anchor(dims);
      let actual = () => rectangle.navigator.navigate_to(pos.x, pos.y, 8, 250);
      let pausy = () => {
        let tl2 = rectangle.navigator.timeline;
        tl2.clear();
        tl2.add(animate.prop(pause(rectangle.y(), actual), rectangle.y));
      };
      let jumpy = () => {
        let tl2 = rectangle.navigator.timeline;
        tl2.clear();
        tl2.add(animate.prop(jump(rectangle.y(), actual), rectangle.y));
      };
      toss() ? jumpy() : actual();
    }, 700);
  };
}
function follow_simple(rectangle) {
  return function(dims) {
    rectangle.navigator.navigate_to(dims.x, dims.y, 8, 250);
  };
}
const First = (() => {
  let rectangle = new Rectangle(0, 0, 100, 100, {unit: "%", strategy: "absolute", material: colored_grid(colors.white, 8)});
  let ref = rectangle.css();
  let inlinecss = () => ref();
  let word = sig("Schedule");
  let html = () => hdom([".test-box", {style: inlinecss}, ["h2", {style: 'font-family: "cirrus";font-weight: 100;'}, word]]);
  let css2 = [".test-box", {
    padding: [[rem(0.5), rem(1)]],
    "font-family": "anthony",
    "background-color": colors.white,
    color: colors.text
  }];
  return {html, css: css2, rectangle};
})();
const Second = (() => {
  let rectangle = new Rectangle(0, 0, 100, 100, {unit: "%", strategy: "absolute"});
  let inlinecss = rectangle.css();
  let html = () => hdom([".test-box", {style: inlinecss}, ["h2", "Schedule"]]);
  return {html, css, rectangle};
})();
const domfromrectangle = (rect2) => {
  let css2 = "";
  let ref = rect2.css();
  let off = sig(offset(365));
  setInterval(() => {
    off(offset(185));
  }, 2e3 + Math.random() * 2e3);
  let inlinecss = () => ref() + `;transform: rotate(${off()}deg);transition: transform 200ms`;
  let html = () => hdom(["div", {style: inlinecss}]);
  return {html, css: css2, rectangle: rect2};
};
let imagematerial = (src) => ({
  css: () => css({
    background: "#fff0",
    "background-image": url(src),
    "background-size": "contain",
    "background-repeat": "no-repeat"
  })
});
const maskcontainer = (first, second, rectangle) => {
  const runreset = (el) => {
    el.rectangle.x(0);
    el.rectangle.y(0);
    el.rectangle.w(100);
    el.rectangle.h(100);
  };
  const reset = () => {
    runreset(first);
    runreset(second);
  };
  const onanimationend = () => {
    console.log("scheduled");
    swap();
    reset();
    setTimeout(_animate, 5);
  };
  const _animate = () => {
    console.log("ran");
    let direction = toss() ? -1 : 1;
    let axis = toss() ? "x" : "y";
    let start = ordered()[1].rectangle[axis]();
    let end = 100 * direction;
    let onend = onanimationend;
    animate.prop([
      {start, end: start, duration: 1500},
      {start, end, duration: 500, onend}
    ], ordered()[1].rectangle[axis]).setEasing("InCubic");
  };
  const ordered = sig([first, second]);
  const swap = () => {
    let f = ordered()[0];
    let s = ordered()[1];
    ordered([s, f]);
  };
  const {x, y} = offscreen();
  rectangle = rectangle ? rectangle : new Rectangle(x, y, 250, 10, {unit: "v", wUnit: "px"});
  const cssref = rectangle.css();
  const inlinecss = mem(() => cssref() + "overflow: hidden;");
  const render2 = (e) => e.html();
  const html = [".masked", {style: inlinecss}, () => each(ordered, render2)];
  onanimationend();
  return {html, css: [".masked", {position: "relative"}, first.css, second.css], rectangle};
};
function fucker() {
  let Alternative = (() => {
    let rectangle2 = new Rectangle(0, 0, 100, 100, {unit: "%", strategy: "absolute", material: colored_grid("white")});
    let inlinecss = rectangle2.css();
    let html = () => hdom([".alt-box", {style: inlinecss}, ["h2", "Alternative"]]);
    return {html, css, rectangle: rectangle2};
  })();
  let Practices = (() => {
    let rectangle2 = new Rectangle(0, 0, 100, 100, {unit: "%", strategy: "absolute", material: colored_grid("white")});
    let inlinecss = rectangle2.css();
    let html = () => hdom([".alt-box", {style: inlinecss}, ["h2", "Practices"]]);
    return {html, css, rectangle: rectangle2};
  })();
  let rectangle = new Rectangle(20, 20, 550, 10, {unit: "v", wUnit: "px"});
  let dom = maskcontainer(Alternative, Practices, rectangle);
  let masked = Child(dom, follow_simple(dom.rectangle));
  space.add(masked);
}
const shape = (src, fn) => {
  let {x, y} = offscreen();
  let rectangle = new Rectangle(x, y, Math.random() * 8 + 5, Math.random() * 8 + 5, {
    unit: "v",
    material: imagematerial(src)
  });
  let domdom = domfromrectangle(rectangle);
  fn = fn ? fn(rectangle) : follow_fn(rectangle, (dims) => ({x: dims.x + offset(3), y: dims.y + offset(2)}));
  return Child(domdom, fn);
};
let tl = (rectangle) => follow_fn(rectangle, (dims) => ({x: dims.x + offset(3), y: dims.y + offset(2)}));
let tr = (rectangle) => follow_fn(rectangle, (dims) => ({x: dims.x + dims.w + offset(3), y: dims.y + offset(2)}));
let br = (rectangle) => follow_fn(rectangle, (dims) => ({x: dims.x + dims.w + offset(3), y: dims.y + dims.h + offset(2)}));
let bl = (rectangle) => follow_fn(rectangle, (dims) => ({x: dims.x + offset(3), y: dims.y + dims.h + offset(2)}));
let randomizer = (rectangle) => {
  let opts = [tl, tr, br, bl];
  let active = opts.map((e) => e(rectangle));
  return (dims) => active[Math.floor(Math.random() * active.length)](dims);
};
function layer_one_shapes() {
  let shapes = Array(5).fill(0).map((e, i) => shape("./shapes/shape_" + (i + 1) + ".png", randomizer));
  shapes.forEach((e) => {
    Information.rectangle.add_child(e);
    space.add(e);
  });
}
layer_one_shapes();
space.add(Information);
space.add(Stage);
space.add(Banner);
space.add(Timing);
function layer_two_shapes() {
  let shapes = Array(3).fill(0).map((e, i) => shape("./shapes/shape_" + (i + 2) + ".png", randomizer));
  shapes.forEach((e) => {
    Banner.rectangle.add_child(e);
    space.add(e);
  });
}
layer_two_shapes();
space.add(Schedule);
function mount_schedule_banner() {
  let dom = maskcontainer(First, Second);
  let masked = Child(dom, follow_simple(dom.rectangle));
  Schedule.rectangle.add_child(masked);
  space.add(masked);
}
mount_schedule_banner();
let button = (click_fn, one, two) => {
  let atts = {onclick: click_fn};
  let text = two;
  if (typeof one == "object")
    Object.assign(atts, one);
  else if (typeof one == "string")
    text = one;
  return ["button", atts, text];
};
function label_number_input(label, getter, setter) {
  return [
    ".label-input",
    ["span.label", label],
    () => hdom(["input", {
      value: getter,
      type: "number",
      oninput: (e) => {
        let value = parseInt(e.target.value);
        if (isNaN(value))
          value = 0;
        setter(value);
      }
    }])
  ];
}
const Easings = {
  linear: (t) => t,
  InQuad: (t) => t * t,
  OutQuad: (t) => t * (2 - t),
  InOutQuad: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  InCubic: (t) => t * t * t,
  OutCubic: (t) => --t * t * t + 1,
  InOutCubic: (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
  InQuart: (t) => t * t * t * t,
  OutQuart: (t) => 1 - --t * t * t * t,
  InOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t,
  InQuint: (t) => t * t * t * t * t,
  OutQuint: (t) => 1 + --t * t * t * t * t,
  InOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t
};
render(Main, document.body);
let comps = [Schedule, Information, Banner, Timing];
